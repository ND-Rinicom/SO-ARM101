<!-- 
index.html
Has URL parameters to configure model and positions
- model:              3D model filename (default: so-101.glb)
- xPos, yPos, zPos:   Model position coordinates (default: 0.0,0.0,0.0)
- cameraZPos:         Camera Z position (default: 7.0) 
- wireframe:          Render mode (0 = ghost, 1 = wireframe) (default: 0)
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Robot Arm</title>
    <style>
      body { margin: 0; }
      /* background: black; */
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@v0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.182.0/examples/jsm/"
        }
    }
    </script>
    <style>
      canvas {
        cursor: grab;
      }

      canvas.rotating {
        cursor: grabbing;
      }

      canvas.panning {
        cursor: all-scroll;
      }

      canvas.zooming {
        cursor: zoom-in;
      }
    </style>
  </head>
  <body>
    <script src="js/mqtt/mqtt.min.js"></script>
	  <script src="js/mqtt/jsonrpcovermqtt.js"></script>
    <script type="module">
    import { loadModel, loadModelWithId, setJointAngles, setJointAnglesForModel, setModelPosition, setRenderMode, setModelVisibility } from '/js/3Dmodels.js';
    import { initCameraControls } from '/js/cameraControls.js';

// Extract parameters from URL
const url = new URL(window.location.href);
const urlParams = new URLSearchParams(url.search);

// Model name (base name without extension)
let modelName = 'so-101'; // default
if (urlParams.has('model')) {
  modelName = urlParams.get('model');
  // Strip .glb extension if provided
  if (modelName.endsWith('.glb')) {
    modelName = modelName.slice(0, -4);
  }
}
// Model position (xPos, yPos, zPos)
const xPos = urlParams.has('xPos') ? parseFloat(urlParams.get('xPos')) : 0;
const yPos = urlParams.has('yPos') ? parseFloat(urlParams.get('yPos')) : 0;
const zPos = urlParams.has('zPos') ? parseFloat(urlParams.get('zPos')) : 0;

// Camera Z position
const cameraZPos = urlParams.has('cameraZPos') ? parseFloat(urlParams.get('cameraZPos')) : 1;

// Render mode: wireframe or ghost
const renderModeParam = urlParams.get('wireframe') || 0;

// Leader model settings
const showLeader = urlParams.get('showLeader') !== '0'; // default true
const leaderColor = urlParams.has('leaderColor') ? parseInt(urlParams.get('leaderColor'), 16) : 0xffffff;
const leaderOpacity = urlParams.has('leaderOpacity') ? parseFloat(urlParams.get('leaderOpacity')) : 0.8;

// Follower model settings
const showFollower = urlParams.get('showFollower') !== '0'; // default true
const followerColor = urlParams.has('followerColor') ? parseInt(urlParams.get('followerColor'), 16) : 0xffffff;
const followerOpacity = urlParams.has('followerOpacity') ? parseFloat(urlParams.get('followerOpacity')) : 0.8;

// Apply settings
setModelPosition(xPos, yPos, zPos);
setRenderMode(renderModeParam == 1);

// Load follower model (actual positions) first - renders underneath
const followerLoaded = showFollower ? await loadModelWithId('./models/' + modelName, 'follower', {x: 0, y: 0, z: 0}, 0, followerColor, followerOpacity) : false;

// Load leader model (intended positions) second - renders on top
const leaderLoaded = showLeader ? await loadModelWithId('./models/' + modelName, 'leader', {x: 0, y: 0, z: 0}, 1, leaderColor, leaderOpacity) : false;

if (!leaderLoaded && !followerLoaded) {
  console.warn('Both models failed to load, skipping MQTT initialization');
} else {
  const jsonRpcService = new JsonRpcService('ws://' + url.hostname + ':9000', 'watchman_robotarm/' + modelName);

  const cameraController = initCameraControls({
    jsonRpcService,
    modelName,
    cameraZPos
  });

  // Handle inbound method calls (server -> client)
  jsonRpcService.onMethodCalled = function(topic, message) {
    const method = message.method;

    if (method === "finger") {
      jsonRpcService.sendMessage('watchman_robotarm', {
        jsonrpc: "2.0",
        id: message.id,
        result: jsonRpcService.clientId
      });
    } else if (method === "set_leader_joint_angles") {
      const joints = message.params?.joints || {};
      // Update leader model with intended positions
      if (leaderLoaded) {
        setJointAnglesForModel('leader', joints);
      } else {
        // Fallback to old behavior if only one model loaded
        setJointAngles(joints);
      }
      return;
    } else if (method === "set_follower_joint_angles") {
      const joints = message.params?.joints || {};
      // Update follower model with actual positions
      if (followerLoaded) {
        setJointAnglesForModel('follower', joints);
      }
      return;
    } else if (method === "change-camera") {
      console.log('Received camera update message:', message);
      const params = message.params || {};
      if (params.clientId && params.clientId === jsonRpcService.clientId) {
        console.log('Received camera update from self, ignoring');
        return;
      }
      cameraController.applyRemoteCamera(params);
      return;
    }
  };
}
    </script>
  </body>
</html>